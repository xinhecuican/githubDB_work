# 03乐观锁和悲观锁

## 目录

- ### 为什么会诞生非互斥同步锁——互斥同步锁的劣势

- ### 什么是乐观锁和悲观锁？

- ### 典型例子

- ### 开销对比

- ### 使用场景

------

## 为什么会诞生非互斥同步锁——互斥同步锁的劣势

- **阻塞和唤醒带来的性能劣势。**
- **永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待线程释放锁的那几个悲催的线程，将永远得不到执行。**
- **优先级反转：假如低优先级线程获得锁并在执行，而高优先级线程需要 等待低优先级线程释放锁才能执行。**

------

## 什么是乐观锁和悲观锁？

- **从是否锁住资源的角度进行分类**

- **悲观锁：**

  - **如果我不锁住这个资源，别人就回来争抢，就会造成数据结果错误，**

    **所以悲观锁为了确保结果的正确性，会在每次获取并修改数据时，**

    **把数据锁住，让其他人无法访问该数据，这样就可以确保数据内容万无一失。**

    **Java中悲观锁的实现就是synchronized和Lock相关类。**

- **乐观锁：**

  - **认为自己在处理对象的时候不会有其他线程来干扰，所以并不会锁住被操作的对象，**

    **在更新的时候，去对比在自己修改期间数据有没有被其他人改变过：**

    **如果过数据没有被改变过，就说明只有自己在操作，那么就正常去修改数据；**

    **如果数据和自己一开始拿到的不一样了，说明其他人在这期间修改过数据，**

    **那么就不能继续刚才的更新数据过程了，会选择放弃、报错、重试等策略。**

    **乐观锁的实现一般都是利用CAS算法来实现的。**

    **乐观锁的典型例子就是原子类、并发容器等**

-------

## 典型例子

- **Git工具也是乐观锁的典型例子。**

- **数据库：**

  select for update就是悲观锁

  用version控制数据库就是乐观锁

------

## 开销对比

- **悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。**

- **相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多。**

------

## 使用场景

- **悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量无用的自旋等消耗。**

  - **临界区有IO操作**
  - **临界区代码复杂或循环量大**
  - **临界区竞争激烈**

- **乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高。**

  

